# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
# GENERATED FILE, DO NOT EDIT MANUALLY!
# ===----------------------------------------------------------------------=== #

import enum
from collections.abc import Iterator, Sequence
from typing import Callable, Generic, TypeVar

from max.mlir import Attribute as MlirAttribute
from max.mlir import Block as MlirBlock
from max.mlir import Context, Location
from max.mlir import Type as MlirType
from max.mlir import Value as MlirValue

from . import (
    dialects as dialects,
)
from . import (
    driver as driver,
)
from . import (
    dtype as dtype,
)
from . import (
    engine as engine,
)
from . import (
    graph as graph,
)
from . import (
    nixl as nixl,
)
from . import (
    profiler as profiler,
)
from . import (
    safetensors as safetensors,
)

class Attribute:
    @staticmethod
    def _from_cmlir(arg: MlirAttribute, /) -> Attribute: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

class NamedAttribute(tuple[str, Attribute]):
    def __init__(self, arg0: str, arg1: Attribute, /) -> None: ...
    @property
    def name(self): ...
    @property
    def value(self) -> Attribute: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[str | Attribute]: ...

class TypeID:
    pass

class Type:
    @staticmethod
    def _from_cmlir(arg: MlirType, /) -> Type: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

T = TypeVar("T", bound=Type)

class Value(Generic[T]):
    @staticmethod
    def _from_cmlir(value: MlirValue, /) -> Value[Type]: ...
    def __eq__(self, arg: object, /) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def type(self) -> T: ...
    @property
    def owner(self) -> Block | Operation: ...
    @property
    def _CAPIPtr(self) -> object: ...

class OpOperand:
    @property
    def value(self) -> Value[Type]: ...
    @value.setter
    def value(self, value: Value[Type], /): ...

class InsertPoint:
    pass

class Block:
    @staticmethod
    def _from_cmlir(arg: MlirBlock, /) -> Block: ...
    def add_argument(self, arg0: Type, arg1: Location, /) -> Value: ...
    @property
    def end(self) -> InsertPoint: ...

class DiscardableAttributes:
    def __getitem__(self, arg: str, /) -> Attribute: ...
    def __setitem__(self, arg0: str, arg1: Attribute, /) -> None: ...
    def __delitem__(self, arg: str, /) -> Attribute: ...
    def __contains__(self, arg: str, /) -> bool: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def keys(self) -> Iterator[str]: ...
    def items(self) -> Iterator[NamedAttribute]: ...
    def values(self) -> Iterator[Attribute]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __repr__(self) -> str: ...

class Operation:
    @staticmethod
    def _from_cmlir(arg: object, /) -> Operation: ...
    def __eq__(self, arg: object, /) -> bool: ...
    @property
    def context(self) -> Context: ...
    @property
    def results(self) -> Sequence[Value[Type]]: ...
    @property
    def regions(self) -> Sequence[Region]: ...
    def verify(self, verify_recursively: bool = True) -> bool: ...
    def move_after(self, arg: Operation, /) -> None: ...
    @property
    def discardable_attributes(self) -> DiscardableAttributes: ...
    @property
    def asm(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def _CAPIPtr(self) -> object: ...

class OpBuilder:
    def __init__(self, arg: InsertPoint, /) -> None: ...

    Op = TypeVar("Op", bound=Operation)
    def create(
        self, type: type[Op], location: Location
    ) -> Callable[..., Op]: ...

class Region:
    @property
    def front(self) -> Block: ...
    @property
    def back(self) -> Block: ...

class _BitVector:
    pass

class _TargetTriple:
    pass

class _RelocationModel(enum.Enum):  # type: ignore
    pass

class _MemoryEffect:
    pass

class SequenceView:
    def __len__(self) -> int: ...
    def __getitem__(self, arg: int, /) -> object: ...
    def __repr__(self) -> str: ...

class Pass:
    @property
    def name(self) -> str: ...
    @property
    def op_name(self) -> str | None: ...
    def __repr__(self) -> str: ...

class OpPassManager:
    pass

def lower(arg0: dialects.builtin.ModuleOp, arg1: Sequence[Pass], /) -> bool: ...

__version__: str
